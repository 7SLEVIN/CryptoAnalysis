\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{setspace} % This package is used to control linespacing; With \onehalfspacing for instance
\usepackage[danish]{babel}
\renewcommand{\danishhyphenmins}{22} % bedre orddeling
\usepackage{bm}
\usepackage{fnbreak}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage[scriptsize]{caption}
\usepackage[danish,textsize=tiny,backgroundcolor=red,bordercolor=blue]{todonotes}
\usepackage[isbn,issn]{dk-bib}
\interfootnotelinepenalty=10000
\usepackage{graphicx}
\usepackage{usecases}
\usepackage{pdfpages}

\addto\captionsdanish{
\renewcommand\abstractname{Abstract}
}
%-----------------------------------------------------
\newcommand{\doctitle}{Worksheet1}
\newcommand{\docsubject}{01435 Cryptanalysis)}
\newcommand{\docauthor}{Christian Ki√¶r s123812}	
\newcommand{\docdate}{\today}
\newcommand{\docplace}{Danmarks Tekniske Universitet}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
%\newcommand{\docsubtitle}{Undertitle}
%-----------------------------------------------------

%-----------Scientific and mathematical packages begin-----------
% Math package
	\usepackage{amsmath}

% Vector symbols and functions (for example \vv)
	\usepackage{esvect}

% Mathematical symbols
	\usepackage{amssymb}
\DeclareMathOperator{\p}{\cdot}
\DeclareMathOperator{\N}{\mathbb{N}}
\DeclareMathOperator{\Z}{\mathbb{Z}}
\DeclareMathOperator{\C}{\mathbb{C}}
\DeclareMathOperator{\R}{\mathbb{R}}
\newcommand{\nn}{\nonumber}
% SI Units
	%\usepackage[output-decimal-marker={,}]{siunitx}		%http://mirrors.dotsrc.org/ctan/macros/latex/begincontrib/siunitx/siunitx.pdf
	%\sisetup{unitsep= \cdot }

% For Chemistry
	%\usepackage{chemscheme}		% http://ctan.org/pkg/chemscheme
	%\usepackage{chemsym}		% http://ctan.org/pkg/chemsym
	%\usepackage{mhchem}			% http://mirrors.dotsrc.org/ctan/macros/latex/contrib/chemstyle/chemstyle.pdf
	%\DeclareSIUnit\Molar{\textsc{m}}
%-----------Scientific and mathematical packages end--------------

% Non-default fonts - has to come _after_ some of the mathematical packages
\usepackage{pxfonts}

% Page margins
\usepackage[left=2.0cm, right=1.5cm]{geometry}

% Hyperref
\usepackage[colorlinks=true,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}
%\usepackage[hidelinks]{hyperref}  
\hypersetup{pdftitle={\doctitle}} 
\hypersetup{pdfsubject={\docsubject}}
\hypersetup{pdfauthor={\docauthor}}

% Setspace
\usepackage{setspace}
\onehalfspacing
%\numberwithin{equation}{section}
% Alter some LaTeX defaults for better treatment of figures:
    % See p.105 of "TeX Unbound" for suggested values.
    % See pp. 199-200 of Lamport's "LaTeX" book for details.
    %   General parameters, for ALL pages:
    \renewcommand{\topfraction}{0.9}	% max fraction of floats at top
    \renewcommand{\bottomfraction}{0.8}	% max fraction of floats at bottom
    %   Parameters for TEXT pages (not float pages):
    \setcounter{topnumber}{2}
    \setcounter{bottomnumber}{2}
    \setcounter{totalnumber}{4}     % 2 may work better
    \setcounter{dbltopnumber}{2}    % for 2-column pages
    \renewcommand{\dbltopfraction}{0.9}	% fit big float above 2-col. text
    \renewcommand{\textfraction}{0.07}	% allow minimal text w. figs
    %   Parameters for FLOAT pages (not text pages):
    \renewcommand{\floatpagefraction}{0.7}	% require fuller float pages
	% N.B.: floatpagefraction MUST be less than topfraction !!
    \renewcommand{\dblfloatpagefraction}{0.7}	% require fuller float pages

	% remember to use [htp] or [htpb] for placement

% Title
\title{
\HRule \\
\textsc{\doctitle} \\
	 \small{\textsl{\docsubtitle}}
\HRule
}
\author{\docauthor\\\small{\docplace}}
\date{\docdate}

% Fancyheader : http://mirrors.dotsrc.org/ctan/macros/latex/contrib/fancyhdr/fancyhdr.pdf
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
%\fancyhead[RO]{\docauthor \hfill \doctitle \hfill\thepage}
\fancyhead[RO]{\doctitle \hfill \docauthor \hfill \thepage /\ref{TotPages}}
% Get rid of annoying error messages
\setlength{\headheight}{14.5pt}
\usepackage{totpages}
\usepackage{sectsty}
\allsectionsfont{\scshape}
\begin{document}
\section*{Exercise 3}
\subsection*{Chosen-plaintext attack(CPA)}
Enigma was broken using both Chosen-plaintext attacks and known-plaintext attacks. We will describe the usage of Chosen-plaintext attacks.
\subsection*{Known-plaintext attack(KPA)}
The A5/1 algorithm was broken using known-plaintext attacks. 
\newpage
\section*{Exercise 5}
\begin{verbatim}
public class Hackz {
	static String Key = null;

	public static void main(String[] args) {

		long startTime1 = System.currentTimeMillis();
		int cntr = 0;
		String key = "AAAAAAAAAAAADDAd", plaintext = "Secretfoemotherd";
		StringBuilder cipher = new StringBuilder(), brutus = new StringBuilder();

		byte[] ciphertext = encrypt(key.getBytes(), plaintext.getBytes());
		for (int i = 0; i < ciphertext.length; i++) {
			cipher.append(ciphertext[i]);
		}

		char[] nkey = new char[16];
		for (int i = 0; i < 16; ++i) {
			nkey[i] = 65;
		}

		while (true) {

			cntr++;
			byte[] brutusCipher = encrypt(byteC(nkey), plaintext.getBytes());
			for (int k = 0; k < brutusCipher.length; k++) {
				brutus.append(brutusCipher[k]);
			}

			if (brutus.toString().equals(cipher.toString())) {
				System.out.println("Key: " + Key);
				System.out.println("i ran: " + cntr + " times");
				long endTime1 = System.currentTimeMillis();
				System.out.println("Took " + (endTime1 - startTime1) + " ms");
				return;
			}
			brutus.setLength(0);
			int index = 15;
			nkey[index]++;
			while (index >= 0 && nkey[index] >= 122) {
				nkey[index] = 65;
				index--;
				if (index < 0) {
					break;
				}
				nkey[index]++;
			}
		}

	}

	public static byte[] byteC(char[] s) {
		StringBuilder temp = new StringBuilder();
		for (int i = 0; i < s.length; i++) {
			temp.append(s[i]);
		}
		Key = temp.toString();
		return temp.toString().getBytes();
	}

	public static byte[] encrypt(byte[] key, byte[] plaintext) {
		byte[] d = new byte[key.length];
		for (int i = 0; i < key.length; i++) {
			d[i] = (byte) (key[i] ^ plaintext[i]);
		}
		return d;
	}

}
\end{verbatim}
\section*{Exercise 6}
The unicity distance is calculated based on a simple substitution cipher, using english letters only. We see captial and lowercase as the same. The unicity distance is calculated by using following equation:
\begin{equation}
|UD| = \frac{log_2(|K|)}{R_L  \cdot log_2(|P|)}
\end{equation}
We use the following:\\
$ |K| = 26!$\\
$ |P| = 26$\\
$ R_L = 0.7$\\	
\begin{equation}
UD=\frac{log_2(26!)}{0.7  \cdot log_2(26)}= \frac{88.39}{0.7 \cdot 4.7} = 26.8
\end{equation}
So the average number of ciphertext characters required to eliminate alle spurious keys is around 27.
\section*{Exercise 9}
The $ \chi^2 $ test is performed on the given data. The four pairs of bit should occour an equal ammount of times, if the random number generator is perfect. But as it's a quite small sample size, there will be fluctations. The following data is given:
\begin{align*}
k_1("11") = 228 \quad e_1("11") =250 \quad k_2("10") = 270 \quad e_2("10") =250 \\ \quad k_3("01") = 271 \quad e_3("01") =250 \quad k_4("00") = 231\quad e_4("00") =250
\end{align*}
The following equation is used:
\begin{equation}
\chi^2 = \frac{(o_1 - e_1)^2}{e_1}+\frac{(o_2 - e_2)^2}{e_2}+ \ldots \frac{(o_k - e_k)^2}{e_k}
\end{equation}
\begin{align*}
\chi^2 = \frac{(228 - 250)^2}{250}+\frac{(270 - 250)^2}{250}+\frac{(271 - 250)^2}{250}+\frac{(231 - 250)^2}{250}=6.744
\end{align*}
Since the degree of freedom is 3 in our example, the probability value is:
\begin{equation}
P=\frac{1}{\Gamma \left( \frac{3}{2} \right)}\cdot \Gamma \left( \frac{3}{2}, \frac{6.744}{2} \right) = 0.08 = 8\%
\end{equation}
A P-value of 0.05 or less is regarded as statistically significant. Therefore our example is regarded as non significant.
\newpage
\section*{Exercise 11}
I've made a encryption tool:
\begin{verbatim}
void encrypt(int *plainText, int initVector){
    
    cipher[0] = key[initVector ^ plainText[0]];
    
    for (int i = 1; i < bitSize; i++) {
        cipher[i] = key[cipher[i - 1] ^ plainText[i]];
    }
}

int main(int argc, const char * argv[])
{   
   
    for (int i = 0; i < bitSize; i++) {
        initVector = i;
        
        encrypt(plaintext, initVector);
        printf("InitVector: %d Cipher: ", initVector);
        for (int j = 0; j < bitSize; j++) {
            printf("%d ", cipher[j]);
        }
        printf("\n");
    }
  
}
\end{verbatim}
The tool encrypts the plaintext, using every 4-bit initialisation vector. The following console output is given:
\begin{verbatim}
InitVector: 0 Cipher: 12 7 1 3 13 5 8 15 11 14 2 4 10 6 0 12 
InitVector: 1 Cipher: 3 13 5 8 15 11 14 2 4 10 6 0 12 7 1 3 
InitVector: 2 Cipher: 4 10 6 0 12 7 1 3 13 5 8 15 11 14 2 4 
InitVector: 3 Cipher: 13 5 8 15 11 14 2 4 10 6 0 12 7 1 3 13 
InitVector: 4 Cipher: 10 6 0 12 7 1 3 13 5 8 15 	11 14 2 4 10 
InitVector: 5 Cipher: 8 15 11 14 2 4 10 6 0 12 7 1 3 13 5 8 
InitVector: 6 Cipher: 0 12 7 1 3 13 5 8 15 11 14 2 4 10 6 0 
InitVector: 7 Cipher: 1 3 13 5 8 15 11 14 2 4 10 6 0 12 7 1 
InitVector: 8 Cipher: 15 11 14 2 4 10 6 0 12 7 1 3 13 5 8 15 
InitVector: 9 Cipher: 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 
InitVector: 10 Cipher: 6 0 12 7 1 3 13 5 8 15 11 14 2 4 10 6 
InitVector: 11 Cipher: 14 2 4 10 6 0 12 7 1 3 13 5 8 15 11 14 
InitVector: 12 Cipher: 7 1 3 13 5 8 15 11 14 2 4 10 6 0 12 7 
InitVector: 13 Cipher: 5 8 15 11 14 2 4 10 6 0 12 7 1 3 13 5 
InitVector: 14 Cipher: 2 4 10 6 0 12 7 1 3 13 5 8 15 11 14 2 
InitVector: 15 Cipher: 11 14 2 4 10 6 0 12 7 1 3 13 5 8 15 11 
\end{verbatim}
We see that every unique initialisation vector, produces a different output of the cipher. We also see that, when the initialisation vector is 9 every number in the cipher text is also 9. This is expected, as 3 XOR 9 = 10 and a p = 10 produces a c = 9 creating a loop.
\end{document}